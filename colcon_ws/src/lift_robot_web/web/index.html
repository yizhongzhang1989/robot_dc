<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<title>lift_robot</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="https://cdn.tailwindcss.com"></script>
<style>
  body { 
    font-family: system-ui, Arial, sans-serif; 
    padding-top: 140px; /* Reserve space for fixed header */
  }
  .dot { width:10px; height:10px; border-radius:50%; display:inline-block; margin-right:6px; }
  .live { background:#10b981; }
  .stale { background:#f59e0b; }
  .disc { background:#ef4444; }
  pre { font-size:12px; }
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }
  .animate-pulse {
    animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  }
  
  /* Fixed header styles */
  .fixed-header {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    background: #f1f5f9;
    z-index: 1000;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    padding: 0.75rem;
    max-height: 140px;
    overflow-y: auto;
  }
</style>
</head>
<body class="bg-slate-100">
  
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- FIXED HEADER: Task Status, Emergency Control, Height Sensor, Force Sensors -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div class="fixed-header">
    <div class="max-w-7xl mx-auto">
      <div class="grid grid-cols-4 gap-3">
        
        <!-- Task Status -->
        <div class="bg-white rounded-lg shadow p-3 border-l-4 border-purple-500">
          <h2 class="font-bold text-sm mb-2 text-purple-700">üìã Task Status</h2>
          <div id="taskStatusBadge" class="inline-block px-2 py-1 rounded text-xs font-semibold bg-gray-300 text-gray-700 mb-1">IDLE</div>
          <div id="taskProgress" class="text-xs text-gray-600">‚Äî</div>
        </div>

        <!-- Emergency Control -->
        <div class="bg-white rounded-lg shadow p-3 border-l-4 border-red-500">
          <h2 class="font-bold text-sm mb-2 text-red-700">üö® Emergency Control</h2>
          <button id="resetBtn" class="w-full px-3 py-2 bg-red-600 text-white text-sm font-semibold rounded hover:bg-red-700 transition">RESET</button>
        </div>

        <!-- Height Sensor -->
        <div class="bg-white rounded-lg shadow p-3 border-l-4 border-blue-500">
          <h2 class="font-bold text-sm mb-2 text-blue-700">üìè Height Sensor</h2>
          <div>
            <span id="heightVal" class="font-mono font-bold text-2xl text-blue-600">‚Äî</span>
            <span class="text-gray-600 ml-1 text-sm">mm</span>
          </div>
          <div class="text-xs text-gray-600 mt-1">
            <span>Freq:</span> <span id="heightFreq" class="font-mono">‚Äî</span>
            <span class="ml-2">Seq:</span> <span id="seq" class="font-mono">‚Äî</span>
          </div>
        </div>

        <!-- Force Sensors -->
        <div class="bg-white rounded-lg shadow p-3 border-l-4 border-amber-500">
          <h2 class="font-bold text-sm mb-2 text-amber-700">‚ö° Force Sensors</h2>
          <div class="grid grid-cols-3 gap-1 text-center">
            <div>
              <div class="text-xs text-gray-600">Right</div>
              <div id="rightForceVal" class="font-mono font-bold text-lg text-blue-600">‚Äî</div>
              <div class="text-xs text-gray-600">N</div>
            </div>
            <div>
              <div class="text-xs text-gray-600">Left</div>
              <div id="leftForceVal" class="font-mono font-bold text-lg text-blue-600">‚Äî</div>
              <div class="text-xs text-gray-600">N</div>
            </div>
            <div class="border-l border-amber-300">
              <div class="text-xs text-amber-700 font-semibold">Total</div>
              <div id="combinedForceVal" class="font-mono font-bold text-lg text-amber-700">‚Äî</div>
              <div class="text-xs text-gray-600">N</div>
            </div>
          </div>
        </div>

      </div>
    </div>
  </div>
  
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- MAIN CONTENT AREA (scrollable) -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div class="max-w-7xl mx-auto px-4 space-y-4">
    
    <!-- Row 1: Control Panel (Left) + Detailed Status (Right) -->
    <div class="grid grid-cols-2 gap-4">
      
      <!-- LEFT: Control Panel - Vertical sections for Manual, Height Loop, Force Loop -->
      <div class="bg-white rounded-lg shadow p-4 border-l-4 border-green-500">
        <h2 class="font-bold text-lg mb-4 text-green-700 flex items-center gap-2">
          üéÆ Control Panel
        </h2>
        
        <!-- Manual Control Section -->
        <div class="mb-4 pb-4 border-b border-gray-200">
          <h3 class="font-semibold text-sm text-gray-700 mb-2 bg-gray-100 px-2 py-1 rounded">
            üïπÔ∏è Manual Control
          </h3>
          <div class="space-y-2 pl-2">
            <div class="flex gap-1 items-center">
              <span class="text-xs font-medium w-20 text-gray-600">Platform:</span>
              <button data-cmd="up" data-target="platform" class="px-3 py-1.5 bg-emerald-600 hover:bg-emerald-700 text-white text-xs font-medium rounded flex-1 transition">‚Üë Up</button>
              <button data-cmd="down" data-target="platform" class="px-3 py-1.5 bg-blue-600 hover:bg-blue-700 text-white text-xs font-medium rounded flex-1 transition">‚Üì Down</button>
              <button data-cmd="stop" data-target="platform" class="px-3 py-1.5 bg-red-600 hover:bg-red-700 text-white text-xs font-medium rounded flex-1 transition">‚ñ† Stop</button>
            </div>
            <div class="flex gap-1 items-center">
              <span class="text-xs font-medium w-20 text-gray-600">Pushrod:</span>
              <button data-cmd="up" data-target="pushrod" class="px-3 py-1.5 bg-emerald-600 hover:bg-emerald-700 text-white text-xs font-medium rounded flex-1 transition">‚Üë Up</button>
              <button data-cmd="down" data-target="pushrod" class="px-3 py-1.5 bg-blue-600 hover:bg-blue-700 text-white text-xs font-medium rounded flex-1 transition">‚Üì Down</button>
              <button data-cmd="stop" data-target="pushrod" class="px-3 py-1.5 bg-red-500 hover:bg-red-600 text-white text-xs font-medium rounded flex-1 transition">‚ñ† Stop</button>
            </div>
          </div>
        </div>
        
        <!-- Height Closed-Loop Control Section -->
        <div class="mb-4 pb-4 border-b border-gray-200">
          <h3 class="font-semibold text-sm text-gray-700 mb-2 bg-blue-100 px-2 py-1 rounded">
            üìè Height Closed-Loop Control
          </h3>
          <div class="space-y-2 pl-2">
            <div class="flex gap-2 items-center">
              <span class="text-xs font-medium w-20 text-gray-600">Platform:</span>
              <input id="targetHeightPlatform" type="number" placeholder="Target (mm)" class="px-2 py-1.5 border border-blue-300 rounded text-xs w-28 focus:ring-2 focus:ring-blue-400" value="750">
              <button id="gotoHeightPlatformBtn" class="px-4 py-1.5 bg-blue-600 hover:bg-blue-700 text-white text-xs font-medium rounded flex-1 transition">‚Üí Go to Height</button>
            </div>
            <div class="flex gap-2 items-center">
              <span class="text-xs font-medium w-20 text-gray-600">Pushrod:</span>
              <input id="targetHeightPushrod" type="number" placeholder="Target (mm)" class="px-2 py-1.5 border border-purple-300 rounded text-xs w-28 focus:ring-2 focus:ring-purple-400" value="750">
              <button id="gotoHeightPushrodBtn" class="px-4 py-1.5 bg-purple-600 hover:bg-purple-700 text-white text-xs font-medium rounded flex-1 transition">‚Üí Go to Height</button>
            </div>
          </div>
        </div>
        
        <!-- Force Closed-Loop Control Section -->
        <div class="mb-2">
          <h3 class="font-semibold text-sm text-gray-700 mb-2 bg-amber-100 px-2 py-1 rounded">
            ‚ö° Force Closed-Loop Control
          </h3>
          <div class="space-y-2 pl-2">
            <div class="flex gap-2 items-center">
              <span class="text-xs font-medium w-20 text-gray-600">Target:</span>
              <input id="targetForcePlatform" type="number" placeholder="Force (N)" class="px-2 py-1.5 border border-amber-300 rounded text-xs w-28 focus:ring-2 focus:ring-amber-400" value="240">
              <span class="text-xs text-gray-600 font-medium">N</span>
            </div>
            <div class="flex gap-2">
              <button id="forceUpBtn" class="px-4 py-2 bg-amber-600 hover:bg-amber-700 text-white text-xs font-medium rounded flex-1 transition">‚Üë Force Up</button>
              <button id="forceDownBtn" class="px-4 py-2 bg-amber-700 hover:bg-amber-800 text-white text-xs font-medium rounded flex-1 transition">‚Üì Force Down</button>
            </div>
          </div>
        </div>
        
        <!-- Command Status -->
        <div id="cmdStatus" class="text-xs text-slate-500 mt-3 p-2 bg-slate-50 rounded text-center"></div>
      </div>
      
      <!-- RIGHT: Detailed Status -->
      <div class="bg-white rounded-lg shadow p-4 border-l-4 border-purple-500">
        <h2 class="font-bold text-lg mb-3 text-purple-700 flex items-center gap-2">
          üîç Detailed Status
        </h2>
        
        <!-- Task Status -->
        <div class="mb-3 pb-3 border-b border-gray-200">
          <h3 class="font-semibold text-sm text-gray-700 mb-2 bg-indigo-100 px-2 py-1 rounded">
            üìã Task Status
          </h3>
          <div class="grid grid-cols-2 gap-2 text-xs bg-slate-50 p-2 rounded">
            <div>State: <span id="taskState" class="font-bold">-</span></div>
            <div>Type: <span id="taskType" class="font-mono">-</span></div>
            <div>Duration: <span id="taskDuration" class="font-mono text-indigo-600">-</span></div>
            <div>Reason: <span id="taskCompletionReason" class="font-mono text-green-700">-</span></div>
          </div>
        </div>
          
        <!-- Platform Status -->
        <div class="mb-3 pb-3 border-b border-gray-200">
          <h3 class="font-semibold text-sm text-gray-700 mb-2 bg-purple-100 px-2 py-1 rounded">
            üèóÔ∏è Platform
          </h3>
          <div class="grid grid-cols-2 gap-2 text-xs bg-slate-50 p-2 rounded">
            <div>Movement: <span id="platformMovement" class="font-mono font-semibold">-</span></div>
            <div>Mode: <span id="platformMode" class="font-mono font-semibold">-</span></div>
            <div>Current: <span id="platformCurrentHeight" class="font-mono text-blue-600">-</span> mm</div>
            <div>Target: <span id="platformTargetHeight" class="font-mono text-green-600">-</span> mm</div>
          </div>
        </div>
        
        <!-- Pushrod Status -->
        <div class="mb-3 pb-3 border-b border-gray-200">
          <h3 class="font-semibold text-sm text-gray-700 mb-2 bg-indigo-100 px-2 py-1 rounded">
            üîß Pushrod
          </h3>
          <div class="grid grid-cols-2 gap-2 text-xs bg-slate-50 p-2 rounded">
            <div>Movement: <span id="pushrodMovement" class="font-mono font-semibold">-</span></div>
            <div>Mode: <span id="pushrodMode" class="font-mono font-semibold">-</span></div>
            <div>Current: <span id="pushrodCurrentHeight" class="font-mono text-blue-600">-</span> mm</div>
            <div>Target: <span id="pushrodTargetHeight" class="font-mono text-green-600">-</span> mm</div>
            <div>Offset: <span id="pushrodOffsetVal" class="font-mono font-semibold text-purple-600">-</span> mm</div>
            <div>Point: <span id="pushrodPoint" class="font-mono">-</span></div>
          </div>
        </div>
        
        <!-- System Info -->
        <div>
          <h3 class="font-semibold text-sm text-gray-700 mb-2 bg-slate-100 px-2 py-1 rounded">
            ‚ÑπÔ∏è Connection Info
          </h3>
          <div class="text-xs bg-slate-50 p-2 rounded space-y-1">
            <div class="flex items-center gap-2">
              <span id="stateDot" class="dot disc"></span>
              <span id="stateText" class="font-medium">Disconnected</span>
            </div>
            <div>Mode: <span id="mode" class="font-mono">WebSocket</span></div>
            <div>Freq: <span id="freq" class="font-mono">-</span> Hz</div>
            <div>Latency: <span id="age" class="font-mono">-</span> ms</div>
            <div class="text-slate-500">Last: <span id="ts" class="font-mono">-</span></div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <!-- CALIBRATION SECTION -->
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    
    <!-- Row 2: Draw Wire (Left) + Force Sensor (Right) -->
    <div class="grid grid-cols-2 gap-4">
      
      <!-- LEFT: Draw Wire Calibration -->
      <div class="bg-white rounded-lg shadow p-4 border-l-4 border-purple-500">
        <div class="flex items-center justify-between mb-3">
          <h2 class="font-bold text-lg text-purple-700 flex items-center gap-2">
            üìè Draw-Wire Sensor Calibration
          </h2>
          <span id="calibStatusBadge" class="px-2 py-1 rounded text-xs font-semibold bg-gray-300 text-gray-700">Loading...</span>
        </div>
        
        <div class="space-y-3">
          <!-- Current Values -->
          <div class="grid grid-cols-3 gap-2 p-2 bg-slate-50 rounded">
            <div class="text-center">
              <div class="text-xs text-slate-500">Sensor</div>
              <div id="calibSensorVal" class="text-lg font-bold text-purple-600">--</div>
            </div>
            <div class="text-center">
              <div class="text-xs text-slate-500">Height</div>
              <div id="calibEstHeight" class="text-lg font-bold text-indigo-600">--</div>
            </div>
            <div class="text-center">
              <div class="text-xs text-slate-500">Samples</div>
              <div id="calibSampleCount" class="text-lg font-bold text-emerald-600">0</div>
            </div>
          </div>
          
          <!-- Calibration Formula -->
          <div id="calibFormulaBox" class="hidden p-2 bg-blue-50 rounded border-l-4 border-blue-400">
            <div class="text-xs text-slate-600">Formula:</div>
            <div id="calibFormula" class="font-mono text-sm text-blue-700">--</div>
          </div>
          
          <!-- Add Sample -->
          <div class="flex gap-2 items-center">
            <label class="text-xs font-semibold text-slate-700 w-24">Actual Height:</label>
            <input id="calibHeightInput" type="number" placeholder="mm" step="0.1" 
                   class="flex-1 px-2 py-1 border border-slate-300 rounded text-sm focus:border-purple-500 focus:ring-1 focus:ring-purple-500">
            <button id="calibAddBtn" class="px-3 py-1 bg-purple-600 hover:bg-purple-700 text-white text-xs font-semibold rounded transition">
              Add
            </button>
          </div>
          
          <!-- Sample List -->
          <div id="calibSamplesList" class="max-h-32 overflow-y-auto border border-slate-200 rounded p-2 text-xs">
            <div class="text-slate-400 text-center">No samples yet</div>
          </div>
          
          <!-- Action Buttons -->
          <div class="grid grid-cols-3 gap-2">
            <button id="calibCalcBtn" class="px-2 py-1 bg-green-600 hover:bg-green-700 text-white text-xs font-semibold rounded transition">
              Calculate
            </button>
            <button id="calibSaveBtn" class="px-2 py-1 bg-blue-600 hover:bg-blue-700 text-white text-xs font-semibold rounded transition">
              Save
            </button>
            <button id="calibClearBtn" class="px-2 py-1 bg-red-600 hover:bg-red-700 text-white text-xs font-semibold rounded transition">
              Clear
            </button>
          </div>
          
          <!-- Calibration Result -->
          <div id="calibResult" class="hidden p-2 bg-green-50 rounded border border-green-200">
            <h3 class="text-xs font-semibold text-green-800 mb-1">Result:</h3>
            <div class="grid grid-cols-2 gap-1 text-xs">
              <div>Scale: <span id="calibResScale" class="font-mono font-semibold">--</span></div>
              <div>Offset: <span id="calibResOffset" class="font-mono font-semibold">--</span></div>
              <div>R¬≤: <span id="calibResR2" class="font-mono font-semibold">--</span></div>
              <div>Max Err: <span id="calibResMaxErr" class="font-mono font-semibold">--</span> mm</div>
              <div class="col-span-2">Avg Err: <span id="calibResAvgErr" class="font-mono font-semibold">--</span> mm</div>
            </div>
          </div>
          
          <div id="calibStatusMsg" class="text-xs text-slate-500"></div>
        </div>
      </div>
      
      <!-- RIGHT: Force Sensor Calibration -->
      <div class="bg-white rounded-lg shadow p-4 border-l-4 border-red-500">
        <div class="flex items-center justify-between mb-3">
          <h2 class="font-bold text-lg text-red-700 flex items-center gap-2">
            ‚ö° Force Sensor Calibration
          </h2>
          <span id="forceCalibStatusBadge" class="px-2 py-1 rounded text-xs font-semibold bg-gray-300 text-gray-700">Loading...</span>
        </div>
        
        <div class="space-y-3">
          <!-- Channel Selector and Current Values -->
          <div class="grid grid-cols-3 gap-2 p-2 bg-slate-50 rounded">
            <div>
              <label class="block text-xs text-slate-500">Channel</label>
              <select id="forceCalibChannel" class="w-full px-2 py-1 border rounded text-sm font-semibold">
                <option value="right">Right (52)</option>
                <option value="left">Left (53)</option>
              </select>
            </div>
            <div class="text-center">
              <div class="text-xs text-slate-500">Sensor</div>
              <div id="forceCalibCurrentSensor" class="text-lg font-bold text-red-600">--</div>
            </div>
            <div class="text-center">
              <div class="text-xs text-slate-500">Samples</div>
              <div id="forceCalibSampleCount" class="text-lg font-bold text-emerald-600">0</div>
            </div>
          </div>
          
          <!-- Tare Button -->
          <button id="forceCalibTareBtn" class="w-full bg-purple-500 hover:bg-purple-600 text-white px-3 py-1.5 rounded text-xs font-medium transition">
            üîÑ Tare Selected Sensor
          </button>
          
          <!-- Calibration Formula -->
          <div id="forceCalibFormulaBox" class="hidden p-2 bg-blue-50 rounded border-l-4 border-blue-400">
            <div class="text-xs text-slate-600">Formula:</div>
            <div id="forceCalibFormula" class="font-mono text-sm text-blue-700">--</div>
          </div>
          
          <!-- Add Sample -->
          <div class="flex gap-2 items-center">
            <label class="text-xs font-semibold text-slate-700 w-24">Actual Force:</label>
            <input id="forceCalibForce" type="number" placeholder="N" step="0.1" 
                   class="flex-1 px-2 py-1 border border-slate-300 rounded text-sm focus:border-red-500 focus:ring-1 focus:ring-red-500">
            <button id="forceCalibAddBtn" class="px-3 py-1 bg-red-600 hover:bg-red-700 text-white text-xs font-semibold rounded transition">
              Add
            </button>
          </div>
          
          <!-- Sample List -->
          <div id="forceCalibSamplesList" class="max-h-32 overflow-y-auto border border-slate-200 rounded p-2 text-xs">
            <div class="text-slate-400 text-center">No samples yet</div>
          </div>
          
          <!-- Action Buttons -->
          <div class="grid grid-cols-3 gap-2">
            <button id="forceCalibCalcBtn" class="px-2 py-1 bg-green-600 hover:bg-green-700 text-white text-xs font-semibold rounded transition">
              Calculate
            </button>
            <button id="forceCalibSaveBtn" class="px-2 py-1 bg-blue-600 hover:bg-blue-700 text-white text-xs font-semibold rounded transition">
              Save
            </button>
            <button id="forceCalibClearBtn" class="px-2 py-1 bg-red-600 hover:bg-red-700 text-white text-xs font-semibold rounded transition">
              Clear
            </button>
          </div>
          
          <!-- Calibration Result -->
          <div id="forceCalibResult" class="hidden p-2 bg-green-50 rounded border border-green-200">
            <h3 class="text-xs font-semibold text-green-800 mb-1">Result:</h3>
            <div class="grid grid-cols-2 gap-1 text-xs">
              <div>Scale: <span id="forceCalibResScale" class="font-mono font-semibold">--</span></div>
              <div>Avg Err: <span id="forceCalibResAvgErr" class="font-mono font-semibold">--</span> N</div>
              <div>Max Err: <span id="forceCalibResMaxErr" class="font-mono font-semibold">--</span> N</div>
              <div>Samples: <span id="forceCalibResSamples" class="font-mono font-semibold">--</span></div>
            </div>
          </div>
          
          <div class="text-xs text-slate-500 italic">
            <strong>Tip:</strong> Tare first, then add weights
          </div>
          
          <div id="forceCalibStatusMsg" class="text-xs text-slate-500"></div>
        </div>
      </div>
    </div>
    
    <!-- Row 3: Platform Overshoot Calibration (Left column only) -->
    <div class="grid grid-cols-2 gap-4">
      
      <!-- LEFT: Platform Overshoot Calibration -->
      <div class="bg-white rounded-lg shadow p-4 border-l-4 border-orange-500">
        <div class="flex items-center justify-between mb-3">
          <h2 class="font-bold text-lg text-orange-700 flex items-center gap-2">
            ‚öôÔ∏è Platform Overshoot Calibration
          </h2>
          <span id="overshootCalibStatusBadge" class="px-2 py-1 rounded text-xs font-semibold bg-gray-300 text-gray-700">Loading...</span>
        </div>
        
      <div class="space-y-3">
        
        <!-- Calibration Range Input -->
        <div class="grid grid-cols-2 gap-2">
          <div>
            <label class="block text-xs font-semibold text-slate-700 mb-1">Lower Bound (mm)</label>
            <input id="overshootLowerBound" type="number" placeholder="910" class="w-full px-2 py-1 border border-slate-300 rounded text-sm focus:border-orange-500 focus:ring-1 focus:ring-orange-500" value="910">
          </div>
          <div>
            <label class="block text-xs font-semibold text-slate-700 mb-1">Upper Bound (mm)</label>
            <input id="overshootUpperBound" type="number" placeholder="945" class="w-full px-2 py-1 border border-slate-300 rounded text-sm focus:border-orange-500 focus:ring-1 focus:ring-orange-500" value="945">
          </div>
        </div>
        
        <!-- Start Calibration Button -->
        <button id="overshootStartBtn" 
                class="w-full px-3 py-2 bg-green-600 text-white text-sm rounded hover:bg-green-700 font-semibold transition">
          ‚ñ∂Ô∏è Start Auto Calibration
        </button>
        
        <!-- Sample Lists -->
        <div class="grid grid-cols-2 gap-2">
          <div class="bg-slate-50 rounded p-2 border border-slate-200">
            <div class="font-semibold text-xs text-orange-600 mb-1">Up Samples</div>
            <div id="overshootSamplesUpList" class="text-xs space-y-1 max-h-24 overflow-auto">
              <div class="text-slate-400">No samples</div>
            </div>
          </div>
          <div class="bg-slate-50 rounded p-2 border border-slate-200">
            <div class="font-semibold text-xs text-orange-600 mb-1">Down Samples</div>
            <div id="overshootSamplesDownList" class="text-xs space-y-1 max-h-24 overflow-auto">
              <div class="text-slate-400">No samples</div>
            </div>
          </div>
        </div>
        
        <!-- Action Buttons -->
        <div class="grid grid-cols-2 gap-2">
          <button id="overshootSaveBtn" class="px-2 py-1 bg-green-600 text-white text-xs rounded hover:bg-green-700 font-semibold transition">
            üíæ Save
          </button>
          <button id="overshootClearBtn" class="px-2 py-1 bg-red-500 text-white text-xs rounded hover:bg-red-600 transition">
            üóëÔ∏è Clear
          </button>
        </div>
        
        <!-- Results Display -->
        <div id="overshootResults" class="bg-slate-50 rounded p-2 border border-slate-200">
          <div class="font-semibold text-xs text-orange-600 mb-2">
            üßÆ Result
          </div>
          <div class="grid grid-cols-2 gap-1 text-xs">
            <div class="col-span-2 bg-green-50 border border-green-200 rounded px-2 py-1">
              <strong class="text-green-700">Upward Overshoot:</strong> 
              <span id="overshootResEmaUp" class="font-mono font-bold text-green-900">--</span> mm
            </div>
            <div class="col-span-2 bg-blue-50 border border-blue-200 rounded px-2 py-1">
              <strong class="text-blue-700">Downward Overshoot:</strong> 
              <span id="overshootResEmaDown" class="font-mono font-bold text-blue-900">--</span> mm
            </div>
          </div>
        </div>
        
        <div class="text-xs text-slate-500 italic">
          <strong>Tip:</strong> Enter range and click Start. System will test 6 points automatically.
        </div>
        
        <div id="overshootStatusMsg" class="text-xs text-slate-500"></div>
      </div>
      </div>
      
      <!-- RIGHT: Empty placeholder -->
      <div></div>
    </div>
    
    <!-- Raw JSON Data -->
    <div class="bg-white rounded-lg shadow">
      <details>
        <summary class="p-3 font-semibold cursor-pointer hover:bg-slate-50 rounded-t-lg">üìÑ Raw JSON Data</summary>
        <div class="p-3 border-t">
          <pre id="raw" class="bg-slate-50 p-2 rounded max-h-72 overflow-auto text-xs font-mono"></pre>
        </div>
      </details>
    </div>
    
  </div>
  <!-- End main content area -->
  
<script>
let ws=null, lastReceive=null; let intervals=[]; let usePolling=false; let pollTimer=null; let readInterval=1000;
function $(id){return document.getElementById(id);} 
function setState(type,text){ const d=$('stateDot'); d.className='dot '+type; $('stateText').textContent=text; }
function connect(){ const proto=location.protocol==='https:'?'wss':'ws'; ws=new WebSocket(proto+'://'+location.host+'/ws'); ws.onopen=()=>{usePolling=false; $('mode').textContent='WebSocket'; setState('live','Live'); if(pollTimer){clearInterval(pollTimer);} }; ws.onmessage=e=>{ if(e.data==='ping') return; handle(e.data); }; ws.onclose=()=>{ setState('disc','Disconnected'); fallback(); setTimeout(connect,3000); }; ws.onerror=()=> setState('disc','Error'); }
function fallback(){ if(usePolling) return; usePolling=true; $('mode').textContent='Polling'; pollTimer=setInterval(async()=>{ try{ const r=await fetch('/api/latest'); if(!r.ok) return; handle(JSON.stringify(await r.json())); }catch(e){} }, 1000); }
function handle(raw){ lastReceive=Date.now(); $('raw').textContent=raw; try{ const data=JSON.parse(raw); update(data); setState('live','Live'); }catch(e){} }
function update(d){
  // Compact mode fields
  if(d.seq_id!==undefined) $('seq').textContent=d.seq_id;
  if(d.height!==undefined) $('heightVal').textContent = (d.height===null?'-':(d.height.toFixed?d.height.toFixed(2):d.height));
  if(d.freq_hz!==undefined) $('heightFreq').textContent = (d.freq_hz && d.freq_hz.toFixed? d.freq_hz.toFixed(2): d.freq_hz);
  // Legacy fallback (timestamp / read_interval)
  if(d.timestamp){ $('ts').textContent=d.timestamp; }
  if(d.read_interval){ readInterval=d.read_interval*1000; }
  
  // Dual channel force sensors (right=device_id 52, left=device_id 53)
  if(d.right_force_sensor!==undefined) {
    const val = (d.right_force_sensor===null?'-':(d.right_force_sensor.toFixed?d.right_force_sensor.toFixed(2):d.right_force_sensor));
    $('rightForceVal').textContent = val;
  }
  if(d.left_force_sensor!==undefined) {
    const val = (d.left_force_sensor===null?'-':(d.left_force_sensor.toFixed?d.left_force_sensor.toFixed(2):d.left_force_sensor));
    $('leftForceVal').textContent = val;
  }
  if(d.combined_force_sensor!==undefined) {
    const val = (d.combined_force_sensor===null?'-':(d.combined_force_sensor.toFixed?d.combined_force_sensor.toFixed(2):d.combined_force_sensor));
    $('combinedForceVal').textContent = val;
  }
  
  // Platform status
  if(d.platform_status){
    const ps = d.platform_status;
    if(ps.movement_state!==undefined) $('platformMovement').textContent=ps.movement_state;
    if(ps.control_mode!==undefined) $('platformMode').textContent=ps.control_mode;
    if(ps.current_height!==undefined) $('platformCurrentHeight').textContent=(ps.current_height.toFixed?ps.current_height.toFixed(2):ps.current_height);
    if(ps.target_height!==undefined) $('platformTargetHeight').textContent=(ps.target_height.toFixed?ps.target_height.toFixed(2):ps.target_height);
  }
  
  // Pushrod status
  if(d.pushrod_status){
    const prs = d.pushrod_status;
    if(prs.movement_state!==undefined) $('pushrodMovement').textContent=prs.movement_state;
    if(prs.control_mode!==undefined) $('pushrodMode').textContent=prs.control_mode;
    if(prs.current_height!==undefined) $('pushrodCurrentHeight').textContent=(prs.current_height.toFixed?prs.current_height.toFixed(2):prs.current_height);
    if(prs.target_height!==undefined) $('pushrodTargetHeight').textContent=(prs.target_height.toFixed?prs.target_height.toFixed(2):prs.target_height);
    if(prs.pushrod_offset!==undefined) $('pushrodOffsetVal').textContent=(prs.pushrod_offset.toFixed?prs.pushrod_offset.toFixed(2):prs.pushrod_offset);
    if(prs.current_point!==undefined) $('pushrodPoint').textContent=prs.current_point;
  }
  
  // Update unified task status
  if(d.platform_status || d.pushrod_status) {
    updateUnifiedTaskStatus(d.platform_status, d.pushrod_status);
  }
  
  computeFreq();
}

// Update unified task status card (merge platform + pushrod)
function updateUnifiedTaskStatus(platformStatus, pushrodStatus) {
  let mergedState = 'idle';
  let mergedType = '-';
  let mergedDuration = '-';
  let mergedReason = '-';
  let activeStatus = null;
  
  // Determine merged state: running takes priority
  const platformState = platformStatus?.task_state || 'idle';
  const pushrodState = pushrodStatus?.task_state || 'idle';
  
  if (platformState === 'running' || pushrodState === 'running') {
    mergedState = 'running';
    // Use the running one's info
    activeStatus = platformState === 'running' ? platformStatus : pushrodStatus;
  } else if (platformState === 'emergency_stop' || pushrodState === 'emergency_stop') {
    mergedState = 'emergency_stop';
    activeStatus = platformState === 'emergency_stop' ? platformStatus : pushrodStatus;
  } else if (platformState === 'completed' || pushrodState === 'completed') {
    mergedState = 'completed';
    // Prefer the most recently completed one (has task_end_time)
    if (platformStatus?.task_end_time && pushrodStatus?.task_end_time) {
      activeStatus = platformStatus.task_end_time > pushrodStatus.task_end_time ? platformStatus : pushrodStatus;
    } else if (platformStatus?.task_end_time) {
      activeStatus = platformStatus;
    } else if (pushrodStatus?.task_end_time) {
      activeStatus = pushrodStatus;
    } else {
      activeStatus = platformStatus || pushrodStatus;
    }
  } else {
    // Both idle - don't show idle unless initial launch
    mergedState = 'completed';
    activeStatus = platformStatus || pushrodStatus;
  }
  
  // Extract info from active status
  if (activeStatus) {
    mergedType = activeStatus.task_type || '-';
    mergedReason = activeStatus.completion_reason || '-';
    
    // Calculate duration
    if (activeStatus.task_duration !== undefined && activeStatus.task_duration !== null) {
      mergedDuration = activeStatus.task_duration.toFixed(2) + 's';
    } else if (activeStatus.task_start_time && !activeStatus.task_end_time && mergedState === 'running') {
      const elapsed = Date.now() / 1000 - activeStatus.task_start_time;
      mergedDuration = elapsed.toFixed(1) + 's';
    }
  }
  
  // Update UI - Detailed Status section
  const taskStateEl = $('taskState');
  taskStateEl.textContent = mergedState.toUpperCase();
  
  // Color coding
  taskStateEl.className = 'font-bold px-4 py-2 rounded-full text-sm';
  if (mergedState === 'running') {
    taskStateEl.className += ' bg-blue-500 text-white animate-pulse shadow-lg';
  } else if (mergedState === 'completed') {
    taskStateEl.className += ' bg-green-500 text-white shadow-md';
  } else if (mergedState === 'emergency_stop') {
    taskStateEl.className += ' bg-red-500 text-white shadow-lg';
  } else {
    taskStateEl.className += ' bg-gray-400 text-white';
  }
  
  $('taskType').textContent = mergedType;
  $('taskDuration').textContent = mergedDuration;
  $('taskCompletionReason').textContent = mergedReason;
  
  // Update UI - Fixed Header Task Status Badge
  const taskStatusBadgeEl = $('taskStatusBadge');
  if (taskStatusBadgeEl) {
    taskStatusBadgeEl.textContent = mergedState.toUpperCase();
    taskStatusBadgeEl.className = 'inline-block px-2 py-1 rounded text-xs font-semibold mb-1';
    if (mergedState === 'running') {
      taskStatusBadgeEl.className += ' bg-blue-500 text-white animate-pulse';
    } else if (mergedState === 'completed') {
      taskStatusBadgeEl.className += ' bg-green-500 text-white';
    } else if (mergedState === 'emergency_stop') {
      taskStatusBadgeEl.className += ' bg-red-500 text-white';
    } else {
      taskStatusBadgeEl.className += ' bg-gray-300 text-gray-700';
    }
  }
  
  // Update Task Progress in Fixed Header
  const taskProgressEl = $('taskProgress');
  if (taskProgressEl) {
    taskProgressEl.textContent = mergedType + ' ‚Ä¢ ' + mergedDuration;
  }
}

function computeFreq(){ intervals.push(Date.now()); if(intervals.length>25) intervals.shift(); if(intervals.length>1){ const diffs=[]; for(let i=1;i<intervals.length;i++) diffs.push(intervals[i]-intervals[i-1]); const avg=diffs.reduce((a,b)=>a+b,0)/diffs.length; $('freq').textContent=(1000/avg).toFixed(2); } }
setInterval(()=>{ if(!lastReceive){ $('age').textContent='-'; return; } const age=Date.now()-lastReceive; $('age').textContent=age; const staleThreshold=Math.max(2500,2.5*readInterval); if(age>staleThreshold){ setState('stale','Stale'); } },500);
connect();

// Command buttons
document.querySelectorAll('button[data-cmd]').forEach(btn=>{
  btn.addEventListener('click', async ()=>{
    const command=btn.getAttribute('data-cmd');
    const target=btn.getAttribute('data-target')||'platform';
    const durationAttr=btn.getAttribute('data-duration');
  const duration=durationAttr?parseFloat(durationAttr):undefined;
  const point=btn.getAttribute('data-point');
    $('cmdStatus').textContent='Sending '+command+' ...';
    const payload={command,target};
  if(duration!==undefined) payload.duration=duration;
  if(point) payload.point=point;
    try {
      const r=await fetch('/api/cmd',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
      if(!r.ok){ $('cmdStatus').textContent='Failed '+command; return; }
      const resp=await r.json();
      $('cmdStatus').textContent='Done '+command+(resp.duration?(' ('+resp.duration+'s)'):'');
      setTimeout(()=>$('cmdStatus').textContent='',2000);
    } catch(e){ $('cmdStatus').textContent='Error'; }
  });
});

// Go to Height button (special handler with input field)
$('gotoHeightPlatformBtn').addEventListener('click', async ()=>{
  const targetHeight = parseFloat($('targetHeightPlatform').value);
  if(isNaN(targetHeight)){
    $('cmdStatus').textContent='Invalid height value';
    setTimeout(()=>$('cmdStatus').textContent='',2000);
    return;
  }
  $('cmdStatus').textContent='Platform going to '+targetHeight+'mm ...';
  const payload={command:'goto_height',target:'platform',target_height:targetHeight};
  try {
    const r=await fetch('/api/cmd',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
    if(!r.ok){ $('cmdStatus').textContent='Failed goto_height (platform)'; return; }
    const resp=await r.json();
    $('cmdStatus').textContent='Platform moving to '+targetHeight+'mm';
    setTimeout(()=>$('cmdStatus').textContent='',3000);
  } catch(e){ $('cmdStatus').textContent='Error'; }
});

// Pushrod fine adjustment button
$('gotoHeightPushrodBtn').addEventListener('click', async ()=>{
  const targetHeight = parseFloat($('targetHeightPushrod').value);
  if(isNaN(targetHeight)){
    $('cmdStatus').textContent='Invalid height value';
    setTimeout(()=>$('cmdStatus').textContent='',2000);
    return;
  }
  $('cmdStatus').textContent='Pushrod fine-tuning to '+targetHeight+'mm ...';
  const payload={command:'goto_height',target:'pushrod',target_height:targetHeight};
  try {
    const r=await fetch('/api/cmd',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
    if(!r.ok){ $('cmdStatus').textContent='Failed goto_height (pushrod)'; return; }
    const resp=await r.json();
    $('cmdStatus').textContent='Pushrod fine-tuning to '+targetHeight+'mm';
    setTimeout(()=>$('cmdStatus').textContent='',3000);
  } catch(e){ $('cmdStatus').textContent='Error'; }
});

// Platform force control buttons
function sendForceCommand(direction){
  const targetForce = parseFloat($('targetForcePlatform').value);
  if(isNaN(targetForce) || targetForce<=0){
    $('cmdStatus').textContent='Invalid force value';
    setTimeout(()=>$('cmdStatus').textContent='',2000);
    return;
  }
  const cmd = direction==='up'?'force_up':'force_down';
  $('cmdStatus').textContent='Platform '+(direction==='up'?'force-up':'force-down')+' to '+targetForce+'N ...';
  const payload={command:cmd,target:'platform',target_force:targetForce};
  fetch('/api/cmd',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)})
    .then(r=>{ if(!r.ok) throw new Error('HTTP '+r.status); return r.json(); })
    .then(()=>{ $('cmdStatus').textContent='Force '+direction+' command sent'; setTimeout(()=>$('cmdStatus').textContent='',3000); })
    .catch(()=>{ $('cmdStatus').textContent='Force command error'; setTimeout(()=>$('cmdStatus').textContent='',3000); });
}
$('forceUpBtn').addEventListener('click', ()=> sendForceCommand('up'));
$('forceDownBtn').addEventListener('click', ()=> sendForceCommand('down'));

// Emergency Reset button
$('resetBtn').addEventListener('click', async ()=>{
  // Direct execution without confirmation dialog
  $('cmdStatus').textContent='üî¥ Sending RESET command...';
  const payload={command:'reset',target:'platform'}; // Web server will send to both
  try {
    const r=await fetch('/api/cmd',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
    if(!r.ok){ 
      $('cmdStatus').textContent='‚ùå Reset failed'; 
      setTimeout(()=>$('cmdStatus').textContent='',3000);
      return; 
    }
    const resp=await r.json();
    $('cmdStatus').textContent='‚úÖ RESET complete - '+resp.target;
    setTimeout(()=>$('cmdStatus').textContent='',5000);
  } catch(e){ 
    $('cmdStatus').textContent='‚ùå Reset error: '+e.message; 
    setTimeout(()=>$('cmdStatus').textContent='',3000);
  }
});

// Calibration functions
async function updateCalibrationStatus() {
  try {
    const resp = await fetch('/api/calibration/status');
    const data = await resp.json();
    
    // Update sensor value
    $('calibSensorVal').textContent = data.latest_sensor !== null ? data.latest_sensor.toFixed(2) : '--';
    
    // Update estimated height
    $('calibEstHeight').textContent = data.estimated_height !== null ? 
      data.estimated_height.toFixed(2) + ' mm' : '--';
    
    // Update sample count
    $('calibSampleCount').textContent = data.num_samples;
    
    // Update calibration formula display
    if (data.calibrated) {
      $('calibFormulaBox').classList.remove('hidden');
      $('calibFormula').textContent = 
        `height = ${data.scale.toFixed(6)} √ó sensor + ${data.offset.toFixed(6)}`;
    } else {
      $('calibFormulaBox').classList.add('hidden');
    }
    
    // Update status badge
    const badge = $('calibStatusBadge');
    if (data.calibrated_at) {
      badge.textContent = `Calibrated ${data.calibrated_at}`;
      badge.className = 'px-2 py-1 rounded text-xs font-semibold bg-green-100 text-green-700';
    } else if (data.calibrated) {
      badge.textContent = 'Default';
      badge.className = 'px-2 py-1 rounded text-xs font-semibold bg-yellow-100 text-yellow-700';
    } else {
      badge.textContent = 'Not Calibrated';
      badge.className = 'px-2 py-1 rounded text-xs font-semibold bg-gray-300 text-gray-700';
    }
    
    // Update sample list
    updateCalibrationSamples();
  } catch (error) {
    console.error('Failed to update calibration status:', error);
  }
}

async function updateCalibrationSamples() {
  try {
    const resp = await fetch('/api/calibration/samples');
    const data = await resp.json();
    
    const list = $('calibSamplesList');
    if (data.samples.length === 0) {
      list.innerHTML = '<div class="text-xs text-slate-400 text-center">No samples yet</div>';
      return;
    }
    
    list.innerHTML = data.samples.map((s, i) => `
      <div class="flex items-center justify-between p-2 mb-1 bg-slate-50 rounded text-xs">
        <span class="font-semibold text-slate-600">#${i+1}</span>
        <span class="font-mono">Sensor: ${s.sensor.toFixed(2)}</span>
        <span class="font-mono">Height: ${s.height.toFixed(2)} mm</span>
        <button onclick="deleteCalibrationSample(${i})" 
                class="px-2 py-1 bg-red-500 hover:bg-red-600 text-white rounded text-xs">
          Delete
        </button>
      </div>
    `).join('');
  } catch (error) {
    console.error('Failed to update samples:', error);
  }
}

async function addCalibrationSample() {
  const input = $('calibHeightInput');
  const height = parseFloat(input.value);
  
  if (isNaN(height)) {
    $('calibStatusMsg').textContent = '‚ùå Please enter a valid height';
    setTimeout(() => $('calibStatusMsg').textContent = '', 3000);
    return;
  }
  
  try {
    const resp = await fetch('/api/calibration/add_sample', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({height: height})
    });
    const data = await resp.json();
    
    if (data.success) {
      input.value = '';
      $('calibStatusMsg').textContent = `‚úÖ Sample added (${data.total_samples} total)`;
      setTimeout(() => $('calibStatusMsg').textContent = '', 3000);
      updateCalibrationStatus();
    } else {
      $('calibStatusMsg').textContent = '‚ùå ' + (data.error || 'Failed to add sample');
      setTimeout(() => $('calibStatusMsg').textContent = '', 3000);
    }
  } catch (error) {
    $('calibStatusMsg').textContent = '‚ùå Failed to add: ' + error.message;
    setTimeout(() => $('calibStatusMsg').textContent = '', 3000);
  }
}

async function deleteCalibrationSample(index) {
  if (!confirm(`Delete sample #${index+1}?`)) return;
  
  try {
    const resp = await fetch(`/api/calibration/samples/${index}`, {
      method: 'DELETE'
    });
    const data = await resp.json();
    
    if (data.success) {
      $('calibStatusMsg').textContent = '‚úÖ Sample deleted';
      setTimeout(() => $('calibStatusMsg').textContent = '', 2000);
      updateCalibrationStatus();
    } else {
      $('calibStatusMsg').textContent = '‚ùå Failed to delete';
      setTimeout(() => $('calibStatusMsg').textContent = '', 2000);
    }
  } catch (error) {
    $('calibStatusMsg').textContent = '‚ùå Failed to delete';
    setTimeout(() => $('calibStatusMsg').textContent = '', 2000);
  }
}

async function clearCalibrationSamples() {
  if (!confirm('Clear all samples?')) return;
  
  try {
    const resp = await fetch('/api/calibration/samples', {
      method: 'DELETE'
    });
    const data = await resp.json();
    
    if (data.success) {
      $('calibResult').classList.add('hidden');
      $('calibStatusMsg').textContent = `‚úÖ Cleared ${data.cleared} samples`;
      setTimeout(() => $('calibStatusMsg').textContent = '', 2000);
      updateCalibrationStatus();
    }
  } catch (error) {
    $('calibStatusMsg').textContent = '‚ùå Failed to clear';
    setTimeout(() => $('calibStatusMsg').textContent = '', 2000);
  }
}

async function calculateCalibration() {
  try {
    const resp = await fetch('/api/calibration/calculate', {
      method: 'POST'
    });
    const data = await resp.json();
    
    if (data.success) {
      // Show result
      $('calibResult').classList.remove('hidden');
      $('calibResScale').textContent = data.scale.toFixed(6);
      $('calibResOffset').textContent = data.offset.toFixed(6);
      $('calibResR2').textContent = data.r_squared.toFixed(4);
      $('calibResMaxErr').textContent = data.max_error_mm.toFixed(3);
      $('calibResAvgErr').textContent = data.avg_error_mm.toFixed(3);
      
      $('calibStatusMsg').textContent = '‚úÖ Calibration calculated successfully';
      setTimeout(() => $('calibStatusMsg').textContent = '', 3000);
      updateCalibrationStatus();
    } else {
      $('calibStatusMsg').textContent = '‚ùå ' + (data.error || 'Failed to calculate');
      setTimeout(() => $('calibStatusMsg').textContent = '', 3000);
    }
  } catch (error) {
    $('calibStatusMsg').textContent = '‚ùå Calculation failed: ' + error.message;
    setTimeout(() => $('calibStatusMsg').textContent = '', 3000);
  }
}

async function saveCalibration() {
  try {
    const resp = await fetch('/api/calibration/save', {
      method: 'POST'
    });
    const data = await resp.json();
    
    if (data.success) {
      $('calibStatusMsg').textContent = `‚úÖ Config saved! ${data.message}`;
      setTimeout(() => $('calibStatusMsg').textContent = '', 10000);
    } else {
      $('calibStatusMsg').textContent = '‚ùå ' + (data.error || 'Failed to save');
      setTimeout(() => $('calibStatusMsg').textContent = '', 3000);
    }
  } catch (error) {
    $('calibStatusMsg').textContent = '‚ùå Save failed: ' + error.message;
    setTimeout(() => $('calibStatusMsg').textContent = '', 3000);
  }
}

// Calibration button event listeners
$('calibAddBtn').addEventListener('click', addCalibrationSample);
$('calibCalcBtn').addEventListener('click', calculateCalibration);
$('calibSaveBtn').addEventListener('click', saveCalibration);
$('calibClearBtn').addEventListener('click', clearCalibrationSamples);

// Enter key to add sample
$('calibHeightInput').addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    addCalibrationSample();
  }
});

// Update calibration status every second
setInterval(updateCalibrationStatus, 1000);

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Platform Overshoot Calibration Functions
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Platform Overshoot Calibration Functions
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Track last processed goto measurement to avoid duplicate samples
let lastProcessedGotoTimestamp = null;
let autoAddedSampleCount = 0;  // Track total auto-added samples
let overshootCalibrationActive = false;  // Calibration mode toggle
let autoCalibrationRunning = false;  // Auto calibration in progress
let autoCalibrationAborted = false;  // Flag to abort calibration

// Generate 6 calibration points with alternating upper/lower half ranges
function generateCalibrationPoints(lowerBound, upperBound, currentHeight) {
  const minSpacing = 4; // Minimum spacing between consecutive points in mm
  const midPoint = (lowerBound + upperBound) / 2;
  const lowerHalf = { min: lowerBound, max: midPoint };
  const upperHalf = { min: midPoint, max: upperBound };
  
  console.log(`[Auto Calib] Generating points: lower=${lowerBound}mm, upper=${upperBound}mm, mid=${midPoint}mm, current=${currentHeight}mm`);
  
  const points = [];
  let currentRange, nextRange;
  
  // Determine starting range based on current position
  if (currentHeight >= lowerBound && currentHeight <= upperBound) {
    // Current position is within range
    if (currentHeight >= midPoint) {
      // In upper half, start from lower half
      console.log('[Auto Calib] Current in upper half, first point from lower half');
      currentRange = lowerHalf;
      nextRange = upperHalf;
    } else {
      // In lower half, start from upper half
      console.log('[Auto Calib] Current in lower half, first point from upper half');
      currentRange = upperHalf;
      nextRange = lowerHalf;
    }
  } else if (currentHeight > upperBound) {
    // Above range, start from lower half
    console.log('[Auto Calib] Current above range, first point from lower half');
    currentRange = lowerHalf;
    nextRange = upperHalf;
  } else {
    // Below range, start from upper half
    console.log('[Auto Calib] Current below range, first point from upper half');
    currentRange = upperHalf;
    nextRange = lowerHalf;
  }
  
  // Generate 6 points, alternating between ranges
  let lastPoint = currentHeight;
  const maxAttempts = 100;
  
  for (let i = 0; i < 6; i++) {
    let validPoint = null;
    
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      // Generate random point in current range
      const candidate = currentRange.min + Math.random() * (currentRange.max - currentRange.min);
      
      // Check spacing from last point
      if (Math.abs(candidate - lastPoint) >= minSpacing) {
        validPoint = candidate;
        break;
      }
    }
    
    if (validPoint === null) {
      // Fallback: use range center or boundary
      if (Math.abs(currentRange.min - lastPoint) >= minSpacing) {
        validPoint = currentRange.min + 0.1;
      } else if (Math.abs(currentRange.max - lastPoint) >= minSpacing) {
        validPoint = currentRange.max - 0.1;
      } else {
        validPoint = (currentRange.min + currentRange.max) / 2;
      }
      console.log(`[Auto Calib] Point ${i + 1}: fallback to ${validPoint.toFixed(1)}mm`);
    }
    
    points.push(validPoint);
    lastPoint = validPoint;
    
    console.log(`[Auto Calib] Point ${i + 1}: ${validPoint.toFixed(1)}mm from ${currentRange.min === lowerHalf.min ? 'lower' : 'upper'} half, distance from last: ${Math.abs(validPoint - (i === 0 ? currentHeight : points[i-1])).toFixed(1)}mm`);
    
    // Swap ranges for next iteration
    [currentRange, nextRange] = [nextRange, currentRange];
  }
  
  return points;
}

// Reset auto calibration state
function resetAutoCalibration() {
  console.log('[Auto Calib] Resetting calibration state');
  autoCalibrationRunning = false;
  autoCalibrationAborted = false;
  overshootCalibrationActive = false;
  lastProcessedGotoTimestamp = null;
  
  const startBtn = $('overshootStartBtn');
  startBtn.textContent = '‚ñ∂Ô∏è Start Auto Calibration';
  startBtn.className = 'w-full px-3 py-2 bg-green-600 text-white text-sm rounded hover:bg-green-700 font-semibold transition';
  startBtn.onclick = startAutoCalibration;
}

// Start auto calibration
async function startAutoCalibration() {
  const lowerBound = parseFloat($('overshootLowerBound').value);
  const upperBound = parseFloat($('overshootUpperBound').value);
  
  if (isNaN(lowerBound) || isNaN(upperBound)) {
    $('overshootStatusMsg').textContent = '‚ùå Please enter valid bounds';
    setTimeout(() => $('overshootStatusMsg').textContent = '', 3000);
    return;
  }
  
  if (lowerBound >= upperBound) {
    $('overshootStatusMsg').textContent = '‚ùå Lower bound must be less than upper bound';
    setTimeout(() => $('overshootStatusMsg').textContent = '', 3000);
    return;
  }
  
  if (upperBound - lowerBound < 10) {
    $('overshootStatusMsg').textContent = '‚ùå Range too small (min 10mm required)';
    setTimeout(() => $('overshootStatusMsg').textContent = '', 3000);
    return;
  }
  
  if (autoCalibrationRunning) {
    $('overshootStatusMsg').textContent = '‚ö†Ô∏è Calibration already running';
    return;
  }
  
  try {
    // Step 1: Get current platform height
    $('overshootStatusMsg').textContent = 'üìè Reading current platform height...';
    const statusRes = await fetch('/api/status');
    if (!statusRes.ok) {
      throw new Error('Failed to get platform status');
    }
    const statusData = await statusRes.json();
    const currentHeight = statusData.platform?.current_height;
    
    if (currentHeight === undefined || currentHeight === null) {
      throw new Error('Could not read current platform height');
    }
    
    console.log('[Auto Calib] Current platform height:', currentHeight);
    
    // Step 2: Generate points based on current position
    const points = generateCalibrationPoints(lowerBound, upperBound, currentHeight);
    console.log('[Auto Calib] Generated points:', points);
    
    if (!points || points.length === 0) {
      throw new Error('Failed to generate calibration points');
    }
    
    // Step 3: Initialize calibration state
    autoCalibrationRunning = true;
    autoCalibrationAborted = false;
    overshootCalibrationActive = true;  // Enable auto sample recording
    lastProcessedGotoTimestamp = null;  // Reset timestamp tracking
    
    console.log('[Auto Calib] Calibration initialized');
    
    // Update UI
    const startBtn = $('overshootStartBtn');
    startBtn.textContent = '‚èπÔ∏è Stop Calibration';
    startBtn.className = 'w-full px-3 py-2 bg-red-600 text-white text-sm rounded hover:bg-red-700 font-semibold transition';
    startBtn.onclick = stopAutoCalibration;
  
  $('overshootStatusMsg').textContent = `üöÄ Starting auto calibration with ${points.length} points...`;
  
  // Execute goto for each point
  for (let i = 0; i < points.length; i++) {
    if (autoCalibrationAborted) {
      $('overshootStatusMsg').textContent = 'üõë Calibration aborted by user';
      console.log('[Auto Calib] Aborted by user');
      break;
    }
    
    const target = points[i];
    console.log(`[Auto Calib] Point ${i + 1}/${points.length}: Sending goto ${target.toFixed(1)}mm`);
    $('overshootStatusMsg').textContent = `üìç Moving to point ${i + 1}/${points.length}: ${target.toFixed(1)}mm`;
    
    try {
      // Send goto command
      const res = await fetch('/api/cmd', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          command: 'goto_height',
          target: 'platform',
          target_height: target
        })
      });
      
      if (!res.ok) {
        const errorData = await res.json();
        throw new Error(errorData.error || 'Failed to send goto command');
      }
      
      console.log(`[Auto Calib] Goto command sent, waiting for movement...`);
      
      // Wait for movement to complete (poll status)
      await waitForMovementComplete();
      
      console.log(`[Auto Calib] Movement complete, waiting 1s for stabilization and sample recording...`);
      
      // Delay for measurement stabilization and auto-sample recording
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      console.log(`[Auto Calib] Point ${i + 1} completed`);
      
    } catch (e) {
      console.error('[Auto Calib] Error at point', i, e);
      $('overshootStatusMsg').textContent = `‚ùå Error at point ${i + 1}: ${e.message}`;
      break;
    }
  }
  
  // Finish calibration
  if (!autoCalibrationAborted) {
    console.log('[Auto Calib] Calibration loop completed, calculating and saving...');
    
    // Auto calculate and save
    $('overshootStatusMsg').textContent = 'üßÆ Calculating overshoot values...';
    await calculateOvershoot();
    
    $('overshootStatusMsg').textContent = 'üíæ Saving calibration...';
    await saveOvershoot();
    
    $('overshootStatusMsg').textContent = '‚úÖ Auto calibration completed and saved!';
    console.log('[Auto Calib] All done!');
  }
  
  // Reset UI
  resetAutoCalibration();
  
  setTimeout(() => {
    if ($('overshootStatusMsg').textContent.includes('completed')) {
      $('overshootStatusMsg').textContent = '';
    }
  }, 5000);
  
  } catch (error) {
    console.error('[Auto Calib] Fatal error:', error);
    $('overshootStatusMsg').textContent = `‚ùå Calibration failed: ${error.message}`;
    resetAutoCalibration();
    setTimeout(() => $('overshootStatusMsg').textContent = '', 5000);
  }
}

function stopAutoCalibration() {
  autoCalibrationAborted = true;
  $('overshootStatusMsg').textContent = '‚è≥ Stopping calibration...';
  // Reset will happen when the loop exits
}

// Wait for platform movement to complete by checking task status
async function waitForMovementComplete() {
  const maxWaitTime = 30000; // 30 seconds max
  const pollInterval = 200; // Check every 200ms
  const startTime = Date.now();
  
  // Phase 1: Wait for task to START (task_type becomes 'goto_height')
  console.log('[Auto Calib] Waiting for goto_height task to start...');
  let taskStarted = false;
  let waitCount = 0;
  
  while (Date.now() - startTime < maxWaitTime) {
    try {
      const res = await fetch('/api/status');
      if (!res.ok) {
        await new Promise(resolve => setTimeout(resolve, pollInterval));
        continue;
      }
      
      const data = await res.json();
      const platform = data.platform;
      
      waitCount++;
      if (waitCount % 10 === 0) { // Log every 2 seconds
        console.log(`[Auto Calib] Waiting for start... task_state="${platform?.task_state}" task_type="${platform?.task_type}"`);
      }
      
      // Task started if task_type is 'goto_height' and task_state is 'running' or 'active'
      if (platform?.task_type === 'goto_height' && 
          (platform?.task_state === 'running' || platform?.task_state === 'active')) {
        console.log('[Auto Calib] Task started:', platform.task_state, platform.task_type);
        taskStarted = true;
        break;
      }
      
    } catch (e) {
      console.error('[Auto Calib] Error fetching status:', e);
    }
    
    await new Promise(resolve => setTimeout(resolve, pollInterval));
  }
  
  if (!taskStarted) {
    throw new Error('Task did not start (timeout)');
  }
  
  // Phase 2: Wait for task to COMPLETE (task_state becomes 'completed' or 'idle')
  console.log('[Auto Calib] Waiting for goto_height task to complete...');
  waitCount = 0;
  
  while (Date.now() - startTime < maxWaitTime) {
    try {
      const res = await fetch('/api/status');
      if (!res.ok) {
        await new Promise(resolve => setTimeout(resolve, pollInterval));
        continue;
      }
      
      const data = await res.json();
      const platform = data.platform;
      
      waitCount++;
      if (waitCount % 10 === 0) { // Log every 2 seconds
        console.log(`[Auto Calib] Waiting for completion... task_state="${platform?.task_state}" task_type="${platform?.task_type}"`);
      }
      
      // Task completed if task_state is 'completed', 'idle', or task_type is no longer goto_height
      if (platform?.task_state === 'completed' || 
          platform?.task_state === 'idle' ||
          (platform?.task_type !== 'goto_height' && platform?.task_state !== 'running')) {
        console.log('[Auto Calib] Task completed:', platform.task_state, 'reason:', platform.completion_reason);
        return true;
      }
      
    } catch (e) {
      console.error('[Auto Calib] Error fetching status:', e);
    }
    
    await new Promise(resolve => setTimeout(resolve, pollInterval));
  }
  
  throw new Error('Task completion timeout');
}

async function updateOvershootStatus() {
  try {
    const res = await fetch('/api/overshoot/status');
    if (!res.ok) return;
    const data = await res.json();
    
    // Update status badge
    const badge = $('overshootCalibStatusBadge');
    if (data.calibrated_at) {
      badge.textContent = `Calibrated ${data.calibrated_at}`;
      badge.className = 'px-2 py-1 rounded text-xs font-semibold bg-green-100 text-green-700';
    } else if (data.calibrated_up || data.calibrated_down) {
      badge.textContent = 'Default';
      badge.className = 'px-2 py-1 rounded text-xs font-semibold bg-yellow-100 text-yellow-700';
    } else {
      badge.textContent = 'Not Calibrated';
      badge.className = 'px-2 py-1 rounded text-xs font-semibold bg-gray-300 text-gray-700';
    }
    
    // Auto-add sample if new goto measurement detected AND calibration is active
    console.log('[Overshoot Debug] calibrationActive:', overshootCalibrationActive, 
                'target:', data.last_goto_target, 
                'actual:', data.last_goto_actual, 
                'direction:', data.last_goto_direction,
                'timestamp:', data.last_goto_timestamp);
    
    if (overshootCalibrationActive && 
        data.last_goto_target !== undefined && 
        data.last_goto_actual !== undefined && 
        data.last_goto_direction && 
        data.last_goto_timestamp) {
      
      console.log('[Overshoot Debug] Conditions met! Last processed:', lastProcessedGotoTimestamp, 'New:', data.last_goto_timestamp);
      
      // Check if this is a new measurement
      if (lastProcessedGotoTimestamp === null || data.last_goto_timestamp > lastProcessedGotoTimestamp) {
        lastProcessedGotoTimestamp = data.last_goto_timestamp;
        
        // Auto-add the sample
        const direction = data.last_goto_direction;
        const target = data.last_goto_target;
        const actual = data.last_goto_actual;
        const stop_height = data.last_goto_stop_height;  // Stop position (for residual overshoot)
        
        console.log('[Overshoot Debug] Auto-adding sample:', {direction, target, actual, stop_height});
        
        try {
          const addRes = await fetch('/api/overshoot/add_sample', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ direction, target, actual, stop_height })
          });
          
          const addData = await addRes.json();
          console.log('[Overshoot Debug] Add result:', addData);
          
          if (addData.success) {
            autoAddedSampleCount++;
            $('overshootStatusMsg').textContent = `‚úì Auto-added ${direction} sample #${autoAddedSampleCount}: residual overshoot=${addData.sample.overshoot.toFixed(2)}mm`;
            
            // Auto-calculate after 3 samples
            const totalSamples = addData.count_up + addData.count_down;
            if (totalSamples >= 3 && (addData.count_up >= 2 || addData.count_down >= 2)) {
              await calculateOvershoot();
              $('overshootStatusMsg').textContent += ' (Auto-calculated)';
            }
            
            setTimeout(() => $('overshootStatusMsg').textContent = '', 5000);
          }
        } catch (e) {
          console.error('Auto-add sample error:', e);
        }
      }
    }
    
    // Update sample lists
    await updateOvershootSamples();
    
  } catch (e) {
    console.error('Overshoot status update error:', e);
  }
}

async function updateOvershootSamples() {
  try {
    const res = await fetch('/api/overshoot/samples');
    if (!res.ok) return;
    const data = await res.json();
    
    // Update up samples list
    const upList = $('overshootSamplesUpList');
    if (data.samples_up && data.samples_up.length > 0) {
      upList.innerHTML = data.samples_up.map((s, i) => {
        // Display: Stop position ‚Üí Stable position (residual drift)
        const stopH = s.stop_height !== null && s.stop_height !== undefined ? s.stop_height.toFixed(1) : '?';
        const actualH = s.actual.toFixed(1);
        const overshoot = s.overshoot.toFixed(2);
        return `
        <div class="flex justify-between items-center bg-slate-50 px-2 py-1 rounded">
          <span>Stop:${stopH} ‚Üí Stable:${actualH} (${overshoot}mm)</span>
          <button onclick="deleteOvershootSample('up', ${i})" class="text-red-500 hover:text-red-700 text-xs">‚úï</button>
        </div>
      `;
      }).join('');
    } else {
      upList.innerHTML = '<div class="text-slate-400">No samples</div>';
    }
    
    // Update down samples list
    const downList = $('overshootSamplesDownList');
    if (data.samples_down && data.samples_down.length > 0) {
      downList.innerHTML = data.samples_down.map((s, i) => {
        const stopH = s.stop_height !== null && s.stop_height !== undefined ? s.stop_height.toFixed(1) : '?';
        const actualH = s.actual.toFixed(1);
        const overshoot = s.overshoot.toFixed(2);
        return `
        <div class="flex justify-between items-center bg-slate-50 px-2 py-1 rounded">
          <span>Stop:${stopH} ‚Üí Stable:${actualH} (${overshoot}mm)</span>
          <button onclick="deleteOvershootSample('down', ${i})" class="text-red-500 hover:text-red-700 text-xs">‚úï</button>
        </div>
      `;
      }).join('');
    } else {
      downList.innerHTML = '<div class="text-slate-400">No samples</div>';
    }
    
  } catch (e) {
    console.error('Overshoot samples update error:', e);
  }
}

async function addOvershootSample() {
  const direction = $('overshootDirection').value;
  const target = parseFloat($('overshootTarget').value);
  const actual = parseFloat($('overshootActual').value);
  
  if (isNaN(target) || isNaN(actual)) {
    $('overshootStatusMsg').textContent = '‚ùå Please enter valid target and actual heights';
    setTimeout(() => $('overshootStatusMsg').textContent = '', 3000);
    return;
  }
  
  try {
    const res = await fetch('/api/overshoot/add_sample', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ direction, target, actual })
    });
    
    const data = await res.json();
    if (data.success) {
      $('overshootStatusMsg').textContent = `‚úì Added ${direction} sample (overshoot: ${data.sample.overshoot.toFixed(2)}mm)`;
      $('overshootTarget').value = '';
      $('overshootActual').value = '';
      await updateOvershootStatus();
    } else {
      $('overshootStatusMsg').textContent = '‚ùå ' + (data.error || 'Failed to add sample');
    }
    setTimeout(() => $('overshootStatusMsg').textContent = '', 3000);
  } catch (e) {
    $('overshootStatusMsg').textContent = '‚ùå Error: ' + e.message;
    setTimeout(() => $('overshootStatusMsg').textContent = '', 3000);
  }
}

async function deleteOvershootSample(direction, index) {
  try {
    const res = await fetch(`/api/overshoot/samples/${direction}/${index}`, {
      method: 'DELETE'
    });
    
    const data = await res.json();
    if (data.success) {
      $('overshootStatusMsg').textContent = '‚úì Sample deleted';
      await updateOvershootStatus();
    } else {
      $('overshootStatusMsg').textContent = '‚ùå ' + (data.error || 'Failed to delete');
    }
    setTimeout(() => $('overshootStatusMsg').textContent = '', 3000);
  } catch (e) {
    $('overshootStatusMsg').textContent = '‚ùå Error: ' + e.message;
    setTimeout(() => $('overshootStatusMsg').textContent = '', 3000);
  }
}

async function clearOvershootSamples() {
  if (!confirm('Clear all overshoot samples (both up and down)?')) return;
  
  try {
    const res = await fetch('/api/overshoot/samples', {
      method: 'DELETE'
    });
    
    const data = await res.json();
    if (data.success) {
      $('overshootStatusMsg').textContent = '‚úì All samples cleared';
      await updateOvershootStatus();
    } else {
      $('overshootStatusMsg').textContent = '‚ùå ' + (data.error || 'Failed to clear');
    }
    setTimeout(() => $('overshootStatusMsg').textContent = '', 3000);
  } catch (e) {
    $('overshootStatusMsg').textContent = '‚ùå Error: ' + e.message;
    setTimeout(() => $('overshootStatusMsg').textContent = '', 3000);
  }
}

async function calculateOvershoot() {
  try {
    const res = await fetch('/api/overshoot/calculate', {
      method: 'POST'
    });
    
    const data = await res.json();
    if (data.success) {
      // Update EMA results (primary values - used for control)
      if (data.ema_up !== null && data.ema_up !== undefined) {
        $('overshootResEmaUp').textContent = data.ema_up.toFixed(3);
      } else {
        $('overshootResEmaUp').textContent = '--';
      }
      
      if (data.ema_down !== null && data.ema_down !== undefined) {
        $('overshootResEmaDown').textContent = data.ema_down.toFixed(3);
      } else {
        $('overshootResEmaDown').textContent = '--';
      }
      
      // Update simple average and std (reference values)
      if (data.avg_up !== null && data.avg_up !== undefined) {
        $('overshootResAvgUp').textContent = data.avg_up.toFixed(3);
        $('overshootResStdUp').textContent = data.std_up.toFixed(3);
      } else {
        $('overshootResAvgUp').textContent = '--';
        $('overshootResStdUp').textContent = '--';
      }
      
      if (data.avg_down !== null && data.avg_down !== undefined) {
        $('overshootResAvgDown').textContent = data.avg_down.toFixed(3);
        $('overshootResStdDown').textContent = data.std_down.toFixed(3);
      } else {
        $('overshootResAvgDown').textContent = '--';
        $('overshootResStdDown').textContent = '--';
      }
      
      // Don't show status message for auto-calculations to avoid clutter
      // $('overshootStatusMsg').textContent = '‚úì Calibration calculated';
      await updateOvershootStatus();
    } else {
      $('overshootStatusMsg').textContent = '‚ùå ' + (data.error || 'Calculation failed');
      setTimeout(() => $('overshootStatusMsg').textContent = '', 3000);
    }
  } catch (e) {
    $('overshootStatusMsg').textContent = '‚ùå Error: ' + e.message;
    setTimeout(() => $('overshootStatusMsg').textContent = '', 3000);
  }
}

async function saveOvershoot() {
  try {
    const res = await fetch('/api/overshoot/save', {
      method: 'POST'
    });
    
    const data = await res.json();
    if (data.success) {
      $('overshootStatusMsg').textContent = `‚úì Saved to ${data.filepath.split('/').pop()}. ${data.message}`;
      await updateOvershootStatus(); // Refresh status badge
    } else {
      $('overshootStatusMsg').textContent = '‚ùå ' + (data.error || 'Save failed');
    }
    setTimeout(() => $('overshootStatusMsg').textContent = '', 3000);
  } catch (e) {
    $('overshootStatusMsg').textContent = '‚ùå Error: ' + e.message;
    setTimeout(() => $('overshootStatusMsg').textContent = '', 3000);
  }
}

// Overshoot calibration button event listeners
$('overshootStartBtn').addEventListener('click', startAutoCalibration);
$('overshootSaveBtn').addEventListener('click', saveOvershoot);
$('overshootClearBtn').addEventListener('click', clearOvershootSamples);

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Force Sensor Calibration Functions (Single Channel Mode)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

async function updateForceCalibStatus() {
  try {
    const res = await fetch('/api/force_calib/status');
    if (!res.ok) return;
    const data = await res.json();
    
    const channel = $('forceCalibChannel').value;
    
    // Update status badge (show "both channels" timestamp if both exist, otherwise individual)
    const badge = $('forceCalibStatusBadge');
    if (data.calibrated_at_right && data.calibrated_at_left) {
      // Both calibrated - show right timestamp (or could show "Both calibrated")
      badge.textContent = `Calibrated ${data.calibrated_at_right}`;
      badge.className = 'px-2 py-1 rounded text-xs font-semibold bg-green-100 text-green-700';
    } else if (data.calibrated_at_right || data.calibrated_at_left) {
      // One channel calibrated
      const ts = data.calibrated_at_right || data.calibrated_at_left;
      badge.textContent = `Calibrated ${ts}`;
      badge.className = 'px-2 py-1 rounded text-xs font-semibold bg-green-100 text-green-700';
    } else if (data.calibrated_right || data.calibrated_left) {
      badge.textContent = 'Default';
      badge.className = 'px-2 py-1 rounded text-xs font-semibold bg-yellow-100 text-yellow-700';
    } else {
      badge.textContent = 'Not Calibrated';
      badge.className = 'px-2 py-1 rounded text-xs font-semibold bg-gray-300 text-gray-700';
    }
    
    // Update current sensor reading based on selected channel
    if (channel === 'right') {
      $('forceCalibCurrentSensor').textContent = data.current_sensor_right !== null ? data.current_sensor_right.toFixed(2) : '--';
      $('forceCalibSampleCount').textContent = data.count_right || 0;
      
      // Update formula and result display
      if (data.scale_right !== null) {
        $('forceCalibFormulaBox').classList.remove('hidden');
        $('forceCalibFormula').textContent = `F_actual = F_sensor √ó ${data.scale_right.toFixed(6)}`;
        $('forceCalibResult').classList.remove('hidden');
        $('forceCalibResScale').textContent = data.scale_right.toFixed(6);
      } else {
        $('forceCalibFormulaBox').classList.add('hidden');
        $('forceCalibResult').classList.add('hidden');
      }
    } else {
      $('forceCalibCurrentSensor').textContent = data.current_sensor_left !== null ? data.current_sensor_left.toFixed(2) : '--';
      $('forceCalibSampleCount').textContent = data.count_left || 0;
      
      // Update formula and result display
      if (data.scale_left !== null) {
        $('forceCalibFormulaBox').classList.remove('hidden');
        $('forceCalibFormula').textContent = `F_actual = F_sensor √ó ${data.scale_left.toFixed(6)}`;
        $('forceCalibResult').classList.remove('hidden');
        $('forceCalibResScale').textContent = data.scale_left.toFixed(6);
      } else {
        $('forceCalibFormulaBox').classList.add('hidden');
        $('forceCalibResult').classList.add('hidden');
      }
    }
    
  } catch (e) {
    console.error('Force calib status update error:', e);
  }
}

async function updateForceCalibSamples() {
  try {
    const res = await fetch('/api/force_calib/samples');
    if (!res.ok) return;
    const data = await res.json();
    
    const channel = $('forceCalibChannel').value;
    const samplesList = $('forceCalibSamplesList');
    
    // Update samples based on selected channel
    const samples = channel === 'right' ? data.samples_right : data.samples_left;
    
    if (samples && samples.length > 0) {
      samplesList.innerHTML = samples.map((s, i) => `
        <div class="flex justify-between items-center bg-slate-50 px-2 py-1 rounded mb-1">
          <span>S:${s.sensor.toFixed(1)} ‚Üí F:${s.force.toFixed(1)}N</span>
          <button onclick="deleteForceCalibSample('${channel}', ${i})" class="text-red-500 hover:text-red-700 text-xs">‚úï</button>
        </div>
      `).join('');
    } else {
      samplesList.innerHTML = '<div class="text-xs text-slate-400 text-center">No samples yet</div>';
    }
    
  } catch (e) {
    console.error('Force calib samples update error:', e);
  }
}

// Update display when channel changes
$('forceCalibChannel').addEventListener('change', async () => {
  await updateForceCalibStatus();
  await updateForceCalibSamples();
});

async function addForceCalibSample() {
  const channel = $('forceCalibChannel').value;
  const force = parseFloat($('forceCalibForce').value);
  
  if (isNaN(force)) {
    $('forceCalibStatusMsg').textContent = '‚ùå Please enter valid force value';
    setTimeout(() => $('forceCalibStatusMsg').textContent = '', 3000);
    return;
  }
  
  try {
    const res = await fetch('/api/force_calib/add_sample', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ channel, force })
    });
    
    const data = await res.json();
    if (data.success) {
      $('forceCalibStatusMsg').textContent = `‚úì Added ${channel} sample: sensor=${data.sample.sensor.toFixed(1)}, force=${force.toFixed(1)}N`;
      $('forceCalibForce').value = '';  // Clear input
      await updateForceCalibStatus();
      await updateForceCalibSamples();
    } else {
      $('forceCalibStatusMsg').textContent = '‚ùå ' + (data.error || 'Failed to add');
    }
    setTimeout(() => $('forceCalibStatusMsg').textContent = '', 3000);
  } catch (e) {
    $('forceCalibStatusMsg').textContent = '‚ùå Error: ' + e.message;
    setTimeout(() => $('forceCalibStatusMsg').textContent = '', 3000);
  }
}

async function deleteForceCalibSample(channel, index) {
  try {
    const res = await fetch(`/api/force_calib/samples/${channel}/${index}`, {
      method: 'DELETE'
    });
    
    const data = await res.json();
    if (data.success) {
      $('forceCalibStatusMsg').textContent = `‚úì Deleted ${channel} sample #${index + 1}`;
      await updateForceCalibStatus();
      await updateForceCalibSamples();
    } else {
      $('forceCalibStatusMsg').textContent = '‚ùå ' + (data.error || 'Failed');
    }
    setTimeout(() => $('forceCalibStatusMsg').textContent = '', 3000);
  } catch (e) {
    $('forceCalibStatusMsg').textContent = '‚ùå Error: ' + e.message;
    setTimeout(() => $('forceCalibStatusMsg').textContent = '', 3000);
  }
}

async function clearForceCalibSamples() {
  const channel = $('forceCalibChannel').value;
  if (!confirm(`Clear all ${channel} force calibration samples?`)) return;
  
  try {
    const res = await fetch('/api/force_calib/samples', {
      method: 'DELETE'
    });
    
    const data = await res.json();
    if (data.success) {
      $('forceCalibStatusMsg').textContent = `‚úì Cleared ${data.cleared_right} right + ${data.cleared_left} left samples`;
      await updateForceCalibStatus();
      await updateForceCalibSamples();
    } else {
      $('forceCalibStatusMsg').textContent = '‚ùå ' + (data.error || 'Failed');
    }
    setTimeout(() => $('forceCalibStatusMsg').textContent = '', 3000);
  } catch (e) {
    $('forceCalibStatusMsg').textContent = '‚ùå Error: ' + e.message;
    setTimeout(() => $('forceCalibStatusMsg').textContent = '', 3000);
  }
}

async function calculateForceCalibration() {
  try {
    const res = await fetch('/api/force_calib/calculate', {
      method: 'POST'
    });
    
    const data = await res.json();
    if (data.success) {
      const channel = $('forceCalibChannel').value;
      
      if (channel === 'right' && data.scale_right !== undefined) {
        $('forceCalibResScale').textContent = data.scale_right.toFixed(6);
        $('forceCalibResAvgErr').textContent = data.avg_error_right.toFixed(3);
        $('forceCalibResMaxErr').textContent = data.max_error_right.toFixed(3);
        $('forceCalibResSamples').textContent = data.num_samples_right;
        $('forceCalibStatusMsg').textContent = `‚úì Right calibrated: scale=${data.scale_right.toFixed(6)} (${data.num_samples_right} samples)`;
      } else if (channel === 'left' && data.scale_left !== undefined) {
        $('forceCalibResScale').textContent = data.scale_left.toFixed(6);
        $('forceCalibResAvgErr').textContent = data.avg_error_left.toFixed(3);
        $('forceCalibResMaxErr').textContent = data.max_error_left.toFixed(3);
        $('forceCalibResSamples').textContent = data.num_samples_left;
        $('forceCalibStatusMsg').textContent = `‚úì Left calibrated: scale=${data.scale_left.toFixed(6)} (${data.num_samples_left} samples)`;
      } else {
        $('forceCalibStatusMsg').textContent = '‚ùå No samples for selected channel';
      }
      await updateForceCalibStatus();
    } else {
      $('forceCalibStatusMsg').textContent = '‚ùå ' + (data.error || 'Calculation failed');
    }
    setTimeout(() => $('forceCalibStatusMsg').textContent = '', 5000);
  } catch (e) {
    $('forceCalibStatusMsg').textContent = '‚ùå Error: ' + e.message;
    setTimeout(() => $('forceCalibStatusMsg').textContent = '', 3000);
  }
}

async function saveForceCalibration() {
  try {
    const res = await fetch('/api/force_calib/save', {
      method: 'POST'
    });
    
    const data = await res.json();
    if (data.success) {
      $('forceCalibStatusMsg').textContent = `‚úì Saved to: ${data.saved_files.join(', ')} - ${data.message}`;
      await updateForceCalibStatus(); // Refresh status badge
    } else {
      $('forceCalibStatusMsg').textContent = '‚ùå ' + (data.error || 'Save failed');
    }
    setTimeout(() => $('forceCalibStatusMsg').textContent = '', 5000);
  } catch (e) {
    $('forceCalibStatusMsg').textContent = '‚ùå Error: ' + e.message;
    setTimeout(() => $('forceCalibStatusMsg').textContent = '', 3000);
  }
}

// Force calibration button event listeners
$('forceCalibAddBtn').addEventListener('click', addForceCalibSample);
$('forceCalibCalcBtn').addEventListener('click', calculateForceCalibration);
$('forceCalibSaveBtn').addEventListener('click', saveForceCalibration);
$('forceCalibClearBtn').addEventListener('click', clearForceCalibSamples);
$('forceCalibTareBtn').addEventListener('click', tareForceCalibSensor);

// Tare force sensor function
async function tareForceCalibSensor() {
  const channel = $('forceCalibChannel').value;
  const device_id = channel === 'right' ? 52 : 53;
  const topic = channel === 'right' ? '/force_sensor' : '/force_sensor_2';
  
  if (!confirm(`Tare ${channel} sensor (device_id=${device_id}, ${topic})?\n\nThis will zero the current force reading.`)) {
    return;
  }
  
  try {
    $('forceCalibStatusMsg').textContent = `‚è≥ Taring ${channel} sensor (${device_id})...`;
    
    const res = await fetch('/api/force_calib/tare', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ channel: channel, device_id: device_id })
    });
    
    const data = await res.json();
    if (data.success) {
      $('forceCalibStatusMsg').textContent = `‚úì ${data.message}`;
      // Refresh status after tare
      setTimeout(async () => {
        await updateForceCalibStatus();
        $('forceCalibStatusMsg').textContent = '';
      }, 2000);
    } else {
      $('forceCalibStatusMsg').textContent = '‚ùå ' + (data.error || 'Tare failed');
    }
    setTimeout(() => $('forceCalibStatusMsg').textContent = '', 5000);
  } catch (e) {
    $('forceCalibStatusMsg').textContent = '‚ùå Error: ' + e.message;
    setTimeout(() => $('forceCalibStatusMsg').textContent = '', 3000);
  }
}

// Enter key to add sample
$('forceCalibForce').addEventListener('keypress', (e) => {
  if (e.key === 'Enter') addForceCalibSample();
});

// Initialize on page load
async function initializePage() {
  // Update draw wire calibration status
  await updateCalibrationStatus();
  
  // Update overshoot calibration status and samples
  await updateOvershootStatus();
  await updateOvershootSamples();
  
  // Update force sensor calibration status and samples
  await updateForceCalibStatus();
  await updateForceCalibSamples();
  
  console.log('Page initialized - all calibration data loaded');
}

// Call initialization when page loads
document.addEventListener('DOMContentLoaded', initializePage);

// Update overshoot status every second (includes auto-add logic)
setInterval(updateOvershootStatus, 1000);

// Update force calibration status every second (for real-time sensor readings)
setInterval(updateForceCalibStatus, 1000);

</script>
</body>
</html>
